<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Nginx支持多域名配置</title>
    <url>/Nginx/Nginx-vhost/</url>
    <content><![CDATA[<h1 id="一、概述："><a href="#一、概述：" class="headerlink" title="一、概述："></a>一、概述：</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;众所周知，没个域名通过DNS解析后都会落在一个对应的服务器IP地址，在全球IPV4地址用尽的情况下。如果域名不断增加，这怎么办呢？或者说，我们手上只有一台服务器资源，一个公网IP地址，但是却有多个域名，这怎么办呢？有没办法把多个域名都指向到这个服务器地址、且每个域名对应的应用内容都不一样呢？答案是：可以的。<br>Nginx开源web服务器，就支持这种诉求，将多个域名绑定到一个共同的IP地址。下面具体描述下，基于nginx服务器，如何进行这一个诉求的操作。</p>
<h1 id="二、具体操作方式："><a href="#二、具体操作方式：" class="headerlink" title="二、具体操作方式："></a>二、具体操作方式：</h1><h2 id="1，环境准备："><a href="#1，环境准备：" class="headerlink" title="1，环境准备："></a>1，环境准备：</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;考虑到实验性环境，我们可以通过自己找一台linux服务器，在局域网内部进行测试验证，或者是通过本机。通过虚拟化软件搭建一台服务器，进行测试验证。</p>
<p>本文章使用的测试如下：<br>Virtualbox搭建一个Centos7服务器环境，固定IP地址为192.168.56.101<br>nginx版本为:<br>        <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) </span><br><span class="line">		built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">		TLS SNI support enabled</span><br><span class="line">		configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/<span class="built_in">log</span>/nginx/error.log --http-log-path=/var/<span class="built_in">log</span>/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=<span class="string">'-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic'</span> --with-ld-opt=<span class="string">'-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E'</span></span><br></pre></td></tr></table></figure><br>        关闭所有的Centos防火墙。</p>
<h2 id="2，操作步骤："><a href="#2，操作步骤：" class="headerlink" title="2，操作步骤："></a>2，操作步骤：</h2><p>首先：安装nginx。<br>&nbsp;&nbsp;&nbsp;&nbsp;这里网上很多教程，就不多论述了，linux下安装比较简单，具体操作步骤可以参考<a href="http://nginx.org" target="_blank" rel="noopener">Nginx官网</a> 或者搜索引擎返回的结果中寻找。</p>
<p>其次：修改配置文件。<br>&nbsp;&nbsp;&nbsp;&nbsp;Nginx有vhost的概念，这个功能就是支持一台服务器包含多个虚拟主机。每个vhost对应一个文件即可。<br>本实验使用的配置文件路径是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>
<p>在目录/etc/nginx下创建一个文件夹vhost用来保存各种虚拟主机的配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/nginx/vhost</span><br></pre></td></tr></table></figure>
<p>然后进入vhost文件夹，分别创建两个vhost配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/nginx/vhost</span><br><span class="line">sudo touch example1.com.conf</span><br><span class="line">sudo touch example2.com.conf</span><br></pre></td></tr></table></figure>

<p>利用分别输入以下内容到这两个配置文件中：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">example1.<span class="keyword">com</span>.<span class="keyword">conf</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">		listen 80;		#监听端口</span><br><span class="line">				server_name     example1.com www.example1.com;#绑定的域名</span><br><span class="line"></span><br><span class="line">				access_log      /home/www-data/log/access_example1.log main;#日志路径</span><br><span class="line"></span><br><span class="line">				location /&#123;	#域名对应应用代码路径,首页内容等</span><br><span class="line">						root /home/www-data/example1.com;</span><br><span class="line">						index index.php index.html index.htm;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">		error_page 500 502 503 504 /50x.html;	#错误页面的配置，这个可以直接使用公用的,如果内容都是一样的话</span><br><span class="line">				location /<span class="number">50</span><span class="keyword">x</span>.html &#123;</span><br><span class="line">				&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">example2.<span class="keyword">com</span>.<span class="keyword">conf</span></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line">		server_name     example2.com www.example2.com;	#这里不同的域名不同的内容</span><br><span class="line"></span><br><span class="line">				access_log      /home/www-data/log/access_example2.log main;</span><br><span class="line"></span><br><span class="line">		location /&#123;</span><br><span class="line">				root /home/www-data/example2.com;		#这里是内容不同</span><br><span class="line">						index index.php index.html index.htm;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		error_page 500 502 503 504 /50x.html;</span><br><span class="line">		location /<span class="number">50</span><span class="keyword">x</span>.html &#123;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置好这两个vhost的虚拟主机配置，然后再/etc/nginx/nginx.conf的http配置域内，通过include指令引入这些vhost配置。如下</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">		log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">				<span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">				'"$http_user_agent" "$http_x_forwarded_for"';</span><br><span class="line"></span><br><span class="line">		access_log  /home/www-data/log/access.log  main;</span><br><span class="line"></span><br><span class="line">		sendfile            on;</span><br><span class="line">		tcp_nopush          on;</span><br><span class="line">		tcp_nodelay         on;</span><br><span class="line">		keepalive_timeout   65;</span><br><span class="line">		types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">		include             /etc/nginx/mime.types;</span><br><span class="line">		default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line"># Load modular configuration <span class="keyword">files</span> from the /etc/nginx/<span class="keyword">conf</span>.d directory.</span><br><span class="line"># See http://nginx.org/<span class="keyword">en</span>/docs/ngx_core_module.html#include</span><br><span class="line"># <span class="keyword">for</span> more information.</span><br><span class="line">		include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">								   server &#123;</span><br><span class="line">								   listen       80 default_server;</span><br><span class="line">								   listen       [::]:80 default_server;</span><br><span class="line">								   server_name  wordpress_server:192-168-56-102;</span><br><span class="line">								   root         /home/www-data/html;</span><br><span class="line">								   <span class="built_in">index</span>       <span class="built_in">index</span>.php <span class="built_in">index</span>.html</span><br><span class="line"># Load configuration <span class="keyword">files</span> <span class="keyword">for</span> the default server block.</span><br><span class="line">include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">error_page 404 /404.html;</span><br><span class="line">location = /<span class="number">40</span><span class="keyword">x</span>.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error_page 500 502 503 504 /50x.html;</span><br><span class="line">location = /<span class="number">50</span><span class="keyword">x</span>.html &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">#在这里引入刚才配置的虚拟文件。</span><br><span class="line">include /etc/nginx/vhosts/*; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，多个域名绑定到一个机器IP已经配置完毕。下面我们来做一个简单的测试。    </p>
<h1 id="三、测试验证"><a href="#三、测试验证" class="headerlink" title="三、测试验证"></a>三、测试验证</h1><p>由于是测试配置的准确性，所以我们直接在两个vhost的目录下创建简单的index.html文件。</p>
<p>example1.com</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"This Example1.com website."</span> &gt;&gt; /home/www-data/exmaple1.com/index.html</span><br></pre></td></tr></table></figure>

<p>example2.com</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"This Example2.com website."</span> &gt;&gt; /home/www-data/example2.com/index.html</span><br></pre></td></tr></table></figure>

<p>配置完毕，重启nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo nginx reload</span><br></pre></td></tr></table></figure>

<p>到此，针对nginx的配置已经完成了。</p>
<p>不过还缺少一个很重要的步骤，就是本地域名的绑定。因为我们的域名都是随机定义的测试域名，需要直接在hosts文件进行域名的绑定。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>

<p>输入以下内容：</p>
<pre><code class="vim">
<span class="number">192.168</span>.<span class="number">56.101</span> example1.<span class="keyword">com</span> www.example1.<span class="keyword">com</span> example2.<span class="keyword">com</span> www.example2.<span class="keyword">com</span>
</code></pre>
<p>打开浏览器，分别输入<a href="http://www.example1.com和http://www.exmaple2.com。" target="_blank" rel="noopener">http://www.example1.com和http://www.exmaple2.com。</a><br>要是配置都没有问题的话，会分别在输入example1.com后看到输出是：This Example1.com website。输入example2.com后看到This Example2.com website。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>Java装箱和拆箱</title>
    <url>/Java/Java%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1/</url>
    <content><![CDATA[<h1 id="一、包装类："><a href="#一、包装类：" class="headerlink" title="一、包装类："></a>一、包装类：</h1><p>  Java是一种面向对象语言，所有的内容都是对象，即使是Application入口main函数，也是需要封装在一个类内部。但是尽管如此java语言内置还是提供了8种基本的数据类型，不过这8种基本类型，不属于类。因此在很场景下无法直接使用。比如集合类以及泛型编程等。故此JDK标准库，针对这8种基本类型，提供了对应的封装类型。<br>  如图：</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>中文名称</th>
<th>长度（字节）</th>
<th>取值范围</th>
<th>包装器类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>布尔类型</td>
<td>未定</td>
<td>true/false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>字符类型</td>
<td>2</td>
<td>描述UTF-16编码中的一个代码单元</td>
<td>Character</td>
</tr>
<tr>
<td>byte</td>
<td>字节类型</td>
<td>1</td>
<td>-128~127</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>数值类型</td>
<td>2</td>
<td>-32768~32768</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>数值类型</td>
<td>4</td>
<td>-2147483648~<br>2147483647<br>(超过20亿)</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>数值类型</td>
<td>8</td>
<td>-92233720368<br>54775808~<br>922337203<br>6854775807</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>数值类型</td>
<td>1</td>
<td>大约+/-3.402823<br>47E+38f<br>(有效位数为6~7位</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>数值类型</td>
<td>1</td>
<td>大约+/-1.7976931348<br>6231570E+308<br>(有效位数15位）</td>
<td>Double</td>
</tr>
</tbody></table>
<ul>
<li><p>注 char类型中描述的代码单元和代码点，单独文章分析 *</p>
<p>相关包装类型的UML图如下：<br><img src="/images/Java-boxing01.jpeg" alt=""></p>
</li>
</ul>
<p>  由图可见，8种基本类型，除了Character和Boolean外，其他的数值类型，都继承自抽象类Number。<br>  并且他们都实现了java.io.Serivalizable和java.lang.Compare接口。这两个接口提供了序列化以及比较功能。</p>
<p>  这里需要关注Number抽象类的几个方法：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">doubleValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">short</span> <span class="title">shortValue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>  和包装类各自实现的方法：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">valueOf</span><br></pre></td></tr></table></figure><br>  这些方法会应用在接下来小节阐述的装箱和拆箱中。</p>
<h1 id="二、装箱和拆箱："><a href="#二、装箱和拆箱：" class="headerlink" title="二、装箱和拆箱："></a>二、装箱和拆箱：</h1><p>  包装类的存在是为了弥补基本类型的非对象属性，使得在面向对象的场景中，基本类型也能通过包装以后能使用。比如集合类和泛型编程场景下，基本类型是无法直接使用的，必须转换为对象；但是Java并没有提供运算符重载，包装类不支持数学运算，因此在需要基本类型的场景下，需要把包装类包含的基本类型值，拆解出来。这过程就是“装箱”和“拆箱”。</p>
<blockquote>
<p>装箱：就是把基本类型封装到其对应的类对象类型中；<br>拆箱：就是把类对象类型拆解称为基本类型。</p>
</blockquote>
<p>  装箱和拆箱是分别通过对应的类对象方法进行操作。在JDK1.5之前，这些操作需要手工完成，比如把整数1封装给Integer对象：Integer I = new Integer(1);而拆箱则需要调用方法：int i = Integer.valueOf(I)。而在JDK1.5之后，这一过程自动由编译器完成，这个过程叫做 “自动装箱”和 “自动拆箱”。装箱的时候可以直接:Integer I = 1; 编译器会自动调用方法构造一个Integer对象，并且初始化为1；拆箱的时候可以直接：int i = I; 编译器自动调用Inteter.intValue()把对象转换为基本类型。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoxAndUnBoxing01</span> </span>&#123;</span><br><span class="line"><span class="number">2</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="number">3</span>         Integer I = <span class="number">1</span>;</span><br><span class="line"><span class="number">4</span>         <span class="keyword">int</span> i = I;</span><br><span class="line"><span class="number">5</span>         <span class="keyword">int</span> j = I + <span class="number">2</span>;</span><br><span class="line"><span class="number">6</span>         Integer J = j;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span>         System.out.println(i);</span><br><span class="line"><span class="number">9</span>         System.out.println(I);</span><br><span class="line"><span class="number">10</span>        System.out.println(j);</span><br><span class="line"><span class="number">11</span>        System.out.println(J);</span><br><span class="line"><span class="number">12</span>     &#125;</span><br><span class="line"><span class="number">13</span> &#125;</span><br></pre></td></tr></table></figure>
<p>编译后通过</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javap -c TestBoxAndUnBoxing01</span><br></pre></td></tr></table></figure>
<p>可以看到以下内容：</p>
<p><img src="/images/Java-boxing02.jpeg" alt=""></p>
<p>通过图片可以看出，自动装箱是通过调用Integer.valueOf方法完成，在以上代码存在两次需要进行装箱的操作，分别是第3行赋值、第6行赋值；自动拆箱则是通过Integer.intValue()方法完成，以上代码存在2次需要拆箱的，分别是第4行赋值和第5行的加法运算，对于第5行的加法运算，先是进行拆箱，然后执行数学运算，最后把结果赋值给变量j。</p>
<h1 id="三、装箱缓存："><a href="#三、装箱缓存：" class="headerlink" title="三、装箱缓存："></a>三、装箱缓存：</h1><p>  通过以上类图我们还可以看到Character、Long、Integer、Short、Byte五个类型都分别有一个内部静态类***Cache。那么这些Cache是用来做什么呢？<br>  通过阅读分析JDK源码，发现这些Cache类对于-128~127之间的基本类型，在各自包装类内部都是通过初始化一个对应的对象数组，然后初始化为-128~127之间的值。比如对于Integer类，new一个256个元素的Integer数组，然后分别初始化为-128~127。同样对于Long就new一个256个元素的Long数组，分别初始化为-128~127。接着在进行自动装箱的过程中，判断对应的数值大小，当对应的数值大小介于-128~127之间，则直接使用该缓存中已经建立好的对象，只有超出该范围，才重新new一个对象。</p>
<p>  这样做的目的其实就是为了提高效率。</p>
<p>  我们不妨看看以下代码：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBoxingCache</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Integer i = -<span class="number">128</span>;</span><br><span class="line">    Integer j = -<span class="number">128</span>;</span><br><span class="line">    Integer k = -<span class="number">129</span>;</span><br><span class="line">    Integer l = -<span class="number">129</span>;</span><br><span class="line">    Integer m = <span class="number">127</span>;</span><br><span class="line">    Integer n = <span class="number">127</span>;</span><br><span class="line">    Integer o = <span class="number">128</span>;</span><br><span class="line">    Integer p = <span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"i == j? :"</span> + (i == j));</span><br><span class="line">    System.out.println(<span class="string">"k == l? :"</span> + (k == l));</span><br><span class="line">    System.out.println(<span class="string">"m == n? :"</span> + (m == n));</span><br><span class="line">    System.out.println(<span class="string">"o == p? :"</span> + (o == p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令行执行：javac TestBoxingCache.java;java TestBoxingCache 后按到以下结果：</span><br><span class="line"></span><br><span class="line">i == j? :<span class="literal">true</span></span><br><span class="line">k == l? :<span class="literal">false</span></span><br><span class="line">m == n? :<span class="literal">true</span></span><br><span class="line">o == p? :<span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p>  我们都知道java语言中的类变量是指向一个特定的对象，而==运算符则是判断两个变量是否指向同一个对象。由此可见i和j；m和n分别是指向同一个对象；就是使用了包装类内部预先缓存的对象；而k和l、o和p则分别指向不同的对象，是装箱过程中，动态生成的。</p>
<h1 id="四、总结："><a href="#四、总结：" class="headerlink" title="四、总结："></a>四、总结：</h1><p>  通过以上分析，我们大概可以简单总结。Java语言是一种面向对象编程语言，但是语言内置的基本类型不属于对象，语言通过标准库为期封装了包装类型(Wrapper)。在1.5以前，需要手工的进行装箱和拆箱；而在1.5以后，这一过程大部分情况下，编译器通过调用valueOf和xxxValue函数自动完成装箱和拆箱。而决定编译器执行装箱和拆箱的时机可以理解为：需要对象的时候就装箱和需要基本类型的时候就拆箱：比如把基本类型赋值给对象类型，函数调用参数传递等赋值场景下；使用集合类；使用泛型参数等等需要对象的场景下，装箱；需要基本类型的情况下，比如数学运算，逻辑运算等等，拆箱。<br>  此外，为了提高效率，在Character、Long、Integer、Short、Byte内部缓存了值为-128~127之间的对象，以便复用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo主题NexT笔记</title>
    <url>/Hexo/Hexo%E4%B8%BB%E9%A2%98NexT%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>今天尝试使用hexo搭建了一个github的博客。考虑到快速上手，就没有去看官方教程，而是直接网上搜索了一个安装的帖子，参考着来一步步操作。<br>使用的hexo是最新版的4.2.0;主题是nexT。</p>
<p>整个安装步骤，基本上没什么大问题，就是在主题的菜单上出现了点小情况：相关菜单，点击的时候总是无法跳转到对应的目标。比如：菜单首页，命名是指定了连接到<a href="http://www.hbean.net。配置下指定是home" target="_blank" rel="noopener">http://www.hbean.net。配置下指定是home</a>: /。可是就是在最终生成的连接上多了“%20”(HTML解码后是空格）。百思不得其解，最后经过替换主题，注意排查后发现是nexT主题下的配置:_config.yml文件中，对菜单的配置，在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">home: / || home</span><br></pre></td></tr></table></figure>


<p>多了个空格。把空格删除了就可以:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">home: /||home</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
